module Fib

  use int.Int

  function fib (n:int) : int
  axiom fib0 : fib 0 = 0
  axiom fib1 : fib 1 = 1
  axiom fibn : forall n:int. n >= 0 -> fib n + fib (n+1) = fib (n+2)

  let f(n:int) : int =
  requires { n >= 0 }                         (* assume: n >= 0 *) (* precondition *)
  ensures { result = fib n }
  let ref i = 0 in                            
  let ref a = 0 in                            
  let ref b = 1 in                            
  while i < n do
    invariant { 0 <= i /\ i <= n }            (* assume: 0 <= i /\ i <= n *)
    invariant { a = fib i /\ b = fib (i+1) }  (* assume: a = fib i /\ b = fib (i+1) *)
    variant { n - i }
                                              (* assume: i < n *)  (* loop guard *)
    b <- a + b ;                              (* assume: b' = a + b *)
    a <- b - a ;                              (* assume: a' = b' - a *)
    i <- i + 1                                (* assume: i' = i + 1 *)
                                              (* prove: 0 <= i' = i + 1 /\ i' = i + 1 <= n *)
                                              (* prove: a' = fib i' /\ b' = fib (i'+1) *)
                                              (* prove: a' = b' - a = a + b - a = b = fib (i+1) = fib i' *)
                                              (* prove: b' = a + b = fib i + fib (i+1) = fib (i+2) = fib (i'+1) *)
  (* prove: 0 <= n - i' = n - (i+1) = (n-i) - 1 < n - i *) (* variant *)
  done ;
                                              (* assume: not (i < n) *) (* negation of loop guard *)
  assert { i = n } ;                          (* prove: ... -> i = n *)
                                              (* assume: i = n *)
  a                                           (* prove:  ... -> a = fib n *)  (* ensures *)

  let rec fib_rec (a : int) (b : int) (i : int) (n : int) : int =
  requires { 0 <= i /\ i <= n }
  requires { a = fib i /\ b = fib (i+1) }
  variant { n - i }
  ensures { result = fib n }
  if i < n
  then let b' = a + b in
       let a' = b' - a in
       let i' = i + 1 in
       fib_rec a' b' i' n  (* precondition = loop invariant *)
  else (* assert { i = n } ; *)
       a  (* postcondition = postcondition of function *)

  let fib_top (n : int) : int =
  requires { n >= 0 }
  ensures { result = fib n }
  let i = 0 in
  let a = 0 in
  let b = 1 in
  fib_rec a b i n (* precondition on fib_rec checks loop invariant is true initially *)

end