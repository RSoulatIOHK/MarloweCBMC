{
  "viewer-property": {
    "properties": {
      "main.assertion.1": {
        "class": "assertion",
        "description": "Are the properties dead-code -- needs to fail",
        "expression": "reach == 0",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 228
        }
      },
      "main.assertion.2": {
        "class": "assertion",
        "description": "Impossible to get a successful contract",
        "expression": "success == 0",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 232
        }
      },
      "main.assertion.3": {
        "class": "assertion",
        "description": "Impossible to get a failing contract",
        "expression": "success == 1",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 233
        }
      },
      "main.assertion.4": {
        "class": "assertion",
        "description": "Ada are preserved!",
        "expression": "initialTotalAda == finalTotalAda",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 237
        }
      },
      "main.assertion.5": {
        "class": "assertion",
        "description": "Dollar are preserved!",
        "expression": "initialTotalDollar == finalTotalDollar",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 238
        }
      },
      "main.assertion.6": {
        "class": "assertion",
        "description": "Always finish on a Close contract",
        "expression": "success != -1",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 244
        }
      },
      "main.assertion.7": {
        "class": "assertion",
        "description": "No ada left in the contract",
        "expression": "adaAdaProviderInternal.amount == 0 && adaDollarProviderInternal.amount == 0",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 247
        }
      },
      "main.assertion.8": {
        "class": "assertion",
        "description": "No dollar left in the contract",
        "expression": "dollarAdaProviderInternal.amount == 0 && dollarDollarProviderInternal.amount == 0",
        "location": {
          "file": "main.c",
          "function": "main",
          "line": 248
        }
      },
      "malloc.assertion.1": {
        "class": "assertion",
        "description": "max allocation size exceeded",
        "expression": "malloc_size <= __CPROVER_max_malloc_size",
        "location": {
          "file": "<builtin-library-malloc>",
          "function": "malloc",
          "line": 31
        }
      },
      "malloc.assertion.2": {
        "class": "assertion",
        "description": "max allocation may fail",
        "expression": "!(0 != 0) || !should_malloc_fail",
        "location": {
          "file": "<builtin-library-malloc>",
          "function": "malloc",
          "line": 36
        }
      },
      "newContract.precondition_instance.1": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)&contract->params) != __CPROVER_POINTER_OBJECT((const void *)&params) || (const char *)(const void *)&params >= (const char *)(void *)&contract->params + (signed long int)sizeof(ContractParameters) /*32ul*/  || (const char *)(void *)&contract->params >= (const char *)(const void *)&params + (signed long int)sizeof(ContractParameters) /*32ul*/ ",
        "location": {
          "file": "setters.c",
          "function": "newContract",
          "line": 63
        }
      },
      "newContract.precondition_instance.2": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(&params) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object))",
        "location": {
          "file": "setters.c",
          "function": "newContract",
          "line": 63
        }
      },
      "newContract.precondition_instance.3": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(&(*contract))) && !(__CPROVER_POINTER_OBJECT(&(*contract)) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(&(*contract)) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(&(*contract)) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(&contract->params) + (unsigned __CPROVER_bitvector[65])sizeof(ContractParameters) /*32*/ ",
        "location": {
          "file": "setters.c",
          "function": "newContract",
          "line": 63
        }
      },
      "newContractState.precondition_instance.1": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)&state->internalWallet) != __CPROVER_POINTER_OBJECT((const void *)internalWallet) || (const char *)(const void *)internalWallet >= (const char *)(void *)&state->internalWallet + (signed long int)sizeof(InternalWallet) /*16ul*/  || (const char *)(void *)&state->internalWallet >= (const char *)(const void *)internalWallet + (signed long int)sizeof(InternalWallet) /*16ul*/ ",
        "location": {
          "file": "setters.c",
          "function": "newContractState",
          "line": 53
        }
      },
      "newContractState.precondition_instance.2": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(internalWallet)) && !IS_INVALID_POINTER(internalWallet) && !(__CPROVER_POINTER_OBJECT(internalWallet) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(internalWallet) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(internalWallet) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(internalWallet) + (unsigned __CPROVER_bitvector[65])sizeof(InternalWallet) /*16*/  && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(internalWallet)) || internalWallet == ((InternalWallet *)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newContractState",
          "line": 53
        }
      },
      "newContractState.precondition_instance.3": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(&(*state))) && !(__CPROVER_POINTER_OBJECT(&(*state)) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(&(*state)) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(&(*state)) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(&state->internalWallet) + (unsigned __CPROVER_bitvector[65])sizeof(InternalWallet) /*16*/ ",
        "location": {
          "file": "setters.c",
          "function": "newContractState",
          "line": 53
        }
      },
      "newContractState.precondition_instance.4": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)state->parties) != __CPROVER_POINTER_OBJECT((const void *)parties) || (const char *)(const void *)parties >= (const char *)(void *)state->parties + (signed long int)(sizeof(Party *) /*8ul*/  * (unsigned long int)numParties) || (const char *)(void *)state->parties >= (const char *)(const void *)parties + (signed long int)(sizeof(Party *) /*8ul*/  * (unsigned long int)numParties)",
        "location": {
          "file": "setters.c",
          "function": "newContractState",
          "line": 55
        }
      },
      "newContractState.precondition_instance.5": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(parties)) && !IS_INVALID_POINTER(parties) && !(__CPROVER_POINTER_OBJECT(parties) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(parties) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(parties) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(parties) + (unsigned __CPROVER_bitvector[65])(sizeof(Party *) /*8ul*/  * (unsigned long int)numParties) && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(parties)) || parties == ((Party **)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newContractState",
          "line": 55
        }
      },
      "newContractState.precondition_instance.6": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(state->parties)) && !IS_INVALID_POINTER(state->parties) && !(__CPROVER_POINTER_OBJECT(state->parties) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(state->parties) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(state->parties) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(state->parties) + (unsigned __CPROVER_bitvector[65])(sizeof(Party *) /*8ul*/  * (unsigned long int)numParties) && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(state->parties)) || state->parties == ((Party **)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newContractState",
          "line": 55
        }
      },
      "newInternalAccount.precondition_instance.1": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)&account->wallet) != __CPROVER_POINTER_OBJECT((const void *)&wallet) || (const char *)(const void *)&wallet >= (const char *)(void *)&account->wallet + (signed long int)sizeof(Wallet) /*16ul*/  || (const char *)(void *)&account->wallet >= (const char *)(const void *)&wallet + (signed long int)sizeof(Wallet) /*16ul*/ ",
        "location": {
          "file": "setters.c",
          "function": "newInternalAccount",
          "line": 37
        }
      },
      "newInternalAccount.precondition_instance.2": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(&wallet) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object))",
        "location": {
          "file": "setters.c",
          "function": "newInternalAccount",
          "line": 37
        }
      },
      "newInternalAccount.precondition_instance.3": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(&(*account))) && !(__CPROVER_POINTER_OBJECT(&(*account)) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(&(*account)) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(&(*account)) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(&account->wallet) + (unsigned __CPROVER_bitvector[65])sizeof(Wallet) /*16*/ ",
        "location": {
          "file": "setters.c",
          "function": "newInternalAccount",
          "line": 37
        }
      },
      "newInternalWallet.precondition_instance.1": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)wallet->accounts) != __CPROVER_POINTER_OBJECT((const void *)accounts) || (const char *)(const void *)accounts >= (const char *)(void *)wallet->accounts + (signed long int)(sizeof(InternalAccount) /*24ul*/  * (unsigned long int)numAccounts) || (const char *)(void *)wallet->accounts >= (const char *)(const void *)accounts + (signed long int)(sizeof(InternalAccount) /*24ul*/  * (unsigned long int)numAccounts)",
        "location": {
          "file": "setters.c",
          "function": "newInternalWallet",
          "line": 45
        }
      },
      "newInternalWallet.precondition_instance.2": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(accounts)) && !IS_INVALID_POINTER(accounts) && !(__CPROVER_POINTER_OBJECT(accounts) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(accounts) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(accounts) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(accounts) + (unsigned __CPROVER_bitvector[65])(sizeof(InternalAccount) /*24ul*/  * (unsigned long int)numAccounts) && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(accounts)) || accounts == ((InternalAccount *)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newInternalWallet",
          "line": 45
        }
      },
      "newInternalWallet.precondition_instance.3": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(wallet->accounts)) && !IS_INVALID_POINTER(wallet->accounts) && !(__CPROVER_POINTER_OBJECT(wallet->accounts) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(wallet->accounts) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(wallet->accounts) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(wallet->accounts) + (unsigned __CPROVER_bitvector[65])(sizeof(InternalAccount) /*24ul*/  * (unsigned long int)numAccounts) && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(wallet->accounts)) || wallet->accounts == ((InternalAccount *)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newInternalWallet",
          "line": 45
        }
      },
      "newParty.precondition_instance.1": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)&party->wallet) != __CPROVER_POINTER_OBJECT((const void *)wallet) || (const char *)(const void *)wallet >= (const char *)(void *)&party->wallet + (signed long int)sizeof(Wallet) /*16ul*/  || (const char *)(void *)&party->wallet >= (const char *)(const void *)wallet + (signed long int)sizeof(Wallet) /*16ul*/ ",
        "location": {
          "file": "setters.c",
          "function": "newParty",
          "line": 29
        }
      },
      "newParty.precondition_instance.2": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(wallet)) && !IS_INVALID_POINTER(wallet) && !(__CPROVER_POINTER_OBJECT(wallet) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(wallet) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(wallet) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(wallet) + (unsigned __CPROVER_bitvector[65])sizeof(Wallet) /*16*/  && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(wallet)) || wallet == ((Wallet *)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newParty",
          "line": 29
        }
      },
      "newParty.precondition_instance.3": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(&(*party))) && !(__CPROVER_POINTER_OBJECT(&(*party)) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(&(*party)) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(&(*party)) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(&party->wallet) + (unsigned __CPROVER_bitvector[65])sizeof(Wallet) /*16*/ ",
        "location": {
          "file": "setters.c",
          "function": "newParty",
          "line": 29
        }
      },
      "newWallet.precondition_instance.1": {
        "class": "precondition_instance",
        "description": "memcpy src/dst overlap",
        "expression": "__CPROVER_POINTER_OBJECT((void *)wallet->tokens) != __CPROVER_POINTER_OBJECT((const void *)tokens) || (const char *)(const void *)tokens >= (const char *)(void *)wallet->tokens + (signed long int)(sizeof(Token) /*8ul*/  * (unsigned long int)numTokens) || (const char *)(void *)wallet->tokens >= (const char *)(const void *)tokens + (signed long int)(sizeof(Token) /*8ul*/  * (unsigned long int)numTokens)",
        "location": {
          "file": "setters.c",
          "function": "newWallet",
          "line": 19
        }
      },
      "newWallet.precondition_instance.2": {
        "class": "precondition_instance",
        "description": "memcpy source region readable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(tokens)) && !IS_INVALID_POINTER(tokens) && !(__CPROVER_POINTER_OBJECT(tokens) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(tokens) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(tokens) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(tokens) + (unsigned __CPROVER_bitvector[65])(sizeof(Token) /*8ul*/  * (unsigned long int)numTokens) && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(tokens)) || tokens == ((Token *)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newWallet",
          "line": 19
        }
      },
      "newWallet.precondition_instance.3": {
        "class": "precondition_instance",
        "description": "memcpy destination region writeable",
        "expression": "!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(wallet->tokens)) && !IS_INVALID_POINTER(wallet->tokens) && !(__CPROVER_POINTER_OBJECT(wallet->tokens) == __CPROVER_POINTER_OBJECT(__CPROVER_deallocated)) && !(__CPROVER_POINTER_OBJECT(wallet->tokens) == __CPROVER_POINTER_OBJECT(__CPROVER_dead_object)) && (unsigned __CPROVER_bitvector[65])__CPROVER_OBJECT_SIZE(wallet->tokens) >= (unsigned __CPROVER_bitvector[65])__CPROVER_POINTER_OFFSET(wallet->tokens) + (unsigned __CPROVER_bitvector[65])(sizeof(Token) /*8ul*/  * (unsigned long int)numTokens) && (!(__CPROVER_POINTER_OBJECT(NULL) == __CPROVER_POINTER_OBJECT(wallet->tokens)) || wallet->tokens == ((Token *)NULL))",
        "location": {
          "file": "setters.c",
          "function": "newWallet",
          "line": 19
        }
      }
    }
  }
}
